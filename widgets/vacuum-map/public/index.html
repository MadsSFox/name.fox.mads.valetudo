<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: var(--homey-background-color, #111);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
    #status {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--homey-text-color, #aaa);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 14px;
      text-align: center;
      line-height: 1.5;
    }
    #status .status-icon {
      font-size: 32px;
      display: block;
      margin-bottom: 8px;
    }
    #status .status-hint {
      font-size: 11px;
      opacity: 0.6;
      margin-top: 4px;
    }

    /* Floor bar */
    #floor-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: none;
      align-items: center;
      gap: 4px;
      padding: 6px 8px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 12px;
      overflow-x: auto;
      white-space: nowrap;
      z-index: 10;
    }
    #floor-bar::-webkit-scrollbar { display: none; }
    .floor-tab {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.08);
      color: var(--homey-text-color, #ccc);
      cursor: pointer;
      flex-shrink: 0;
      transition: background 0.15s, border-color 0.15s;
    }
    .floor-tab:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }
    .floor-tab.selected {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
      font-weight: 600;
    }
    .floor-tab.disabled {
      opacity: 0.4;
      cursor: default;
    }
    .floor-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #4caf50;
      display: none;
    }
    .floor-tab.active .floor-dot { display: inline-block; }
    .floor-gear {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.08);
      color: var(--homey-text-color, #ccc);
      cursor: pointer;
      flex-shrink: 0;
      font-size: 14px;
      transition: background 0.15s;
    }
    .floor-gear:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Switch floor button */
    #switch-floor-btn {
      position: absolute;
      top: 38px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      padding: 4px 12px;
      border-radius: 10px;
      border: 1px solid rgba(76, 175, 80, 0.5);
      background: rgba(76, 175, 80, 0.2);
      color: #4caf50;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 11px;
      cursor: pointer;
      z-index: 10;
      transition: background 0.15s;
    }
    #switch-floor-btn:hover {
      background: rgba(76, 175, 80, 0.35);
    }
    #switch-floor-btn.switching {
      opacity: 0.6;
      cursor: wait;
    }

    /* Toast */
    #toast {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 16px;
      border-radius: 14px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 12px;
      color: #fff;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 20;
      white-space: nowrap;
      max-width: 90%;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #toast.show { opacity: 1; }
    #toast.info { background: rgba(33, 150, 243, 0.85); }
    #toast.success { background: rgba(76, 175, 80, 0.85); }
    #toast.error { background: rgba(244, 67, 54, 0.85); }

    /* Switching overlay */
    #switching-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 15;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: var(--homey-text-color, #eee);
    }
    #switching-overlay.show { display: flex; }
    .switching-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid rgba(255, 255, 255, 0.15);
      border-top-color: #4caf50;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 12px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .switching-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }
    .switching-spinner.error {
      animation: none;
      border-color: transparent;
      border-top-color: transparent;
      width: auto;
      height: auto;
      font-size: 32px;
      line-height: 1;
    }
    .switching-spinner.success {
      animation: none;
      border-color: transparent;
      border-top-color: transparent;
      width: auto;
      height: auto;
      font-size: 32px;
      line-height: 1;
    }
    .switching-dismiss {
      margin-top: 14px;
      padding: 6px 20px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(255, 255, 255, 0.1);
      color: var(--homey-text-color, #ccc);
      cursor: pointer;
      font-size: 12px;
      font-family: inherit;
      display: none;
    }
    .switching-dismiss.show { display: block; }
    .switching-step {
      font-size: 11px;
      opacity: 0.7;
    }

    /* Floor management overlay */
    #floor-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
    }
    #floor-overlay.show { display: flex; }
    #floor-panel {
      background: #1a1a1a;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 16px;
      min-width: 240px;
      max-width: 90%;
      max-height: 80%;
      overflow-y: auto;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: var(--homey-text-color, #eee);
    }
    #floor-panel h3 {
      font-size: 14px;
      margin-bottom: 12px;
      font-weight: 600;
    }
    .floor-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }
    .floor-item:last-child { border-bottom: none; }
    .floor-item-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .floor-item-dot.active-dot { background: #4caf50; }
    .floor-item-dot.inactive-dot { background: rgba(255, 255, 255, 0.2); }
    .floor-item-name {
      flex: 1;
      background: none;
      border: 1px solid transparent;
      border-radius: 4px;
      color: inherit;
      font-size: 13px;
      padding: 2px 4px;
      font-family: inherit;
      outline: none;
      min-width: 0;
    }
    .floor-item-name:focus {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.08);
    }
    .floor-item-dock {
      background: none;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      padding: 2px 6px;
      opacity: 0.5;
      transition: opacity 0.15s, border-color 0.15s;
      flex-shrink: 0;
      line-height: 1;
    }
    .floor-item-dock:hover { opacity: 0.8; }
    .floor-item-dock.has-dock {
      opacity: 1;
      border-color: rgba(76, 175, 80, 0.6);
    }
    .floor-item-delete {
      background: none;
      border: none;
      color: #f44336;
      cursor: pointer;
      font-size: 16px;
      padding: 2px 6px;
      border-radius: 4px;
      opacity: 0.6;
      transition: opacity 0.15s;
    }
    .floor-item-delete:hover { opacity: 1; }
    .floor-item-delete:disabled { opacity: 0.15; cursor: default; }
    #floor-panel-close {
      display: block;
      margin: 12px auto 0;
      padding: 6px 20px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.1);
      color: var(--homey-text-color, #ccc);
      cursor: pointer;
      font-size: 12px;
    }
    .floor-item-confirm {
      display: none;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: #f44336;
    }
    .floor-item-confirm.show { display: flex; }
    .floor-item-confirm button {
      background: none;
      border: 1px solid;
      border-radius: 4px;
      padding: 1px 8px;
      cursor: pointer;
      font-size: 11px;
    }
    .floor-item-confirm .confirm-yes {
      color: #f44336;
      border-color: #f44336;
    }
    .floor-item-confirm .confirm-no {
      color: #aaa;
      border-color: #aaa;
    }
  </style>
</head>
<body>
  <div id="status">Loading map…</div>
  <canvas id="map"></canvas>

  <div id="floor-bar"></div>
  <button id="switch-floor-btn">Switch robot to this floor</button>

  <div id="toast"></div>

  <div id="switching-overlay">
    <div class="switching-spinner" id="switching-spinner"></div>
    <div class="switching-title" id="switching-title">Switching floor…</div>
    <div class="switching-step" id="switching-step">Preparing…</div>
    <button class="switching-dismiss" id="switching-dismiss">OK</button>
  </div>

  <div id="floor-overlay">
    <div id="floor-panel">
      <h3>Manage Floors</h3>
      <div id="floor-list"></div>
      <button id="floor-panel-close">Close</button>
    </div>
  </div>

  <script>
    // Segment color palette
    var SEGMENT_COLORS = [
      '#56affc', '#fc5656', '#56fc7e', '#fcb056',
      '#b056fc', '#56fce8', '#fc56b0', '#a2fc56',
      '#5668fc', '#fce856', '#fc5680', '#56fcb0'
    ];

    var canvas = document.getElementById('map');
    var ctx = canvas.getContext('2d');
    var statusEl = document.getElementById('status');
    var floorBarEl = document.getElementById('floor-bar');
    var switchFloorBtn = document.getElementById('switch-floor-btn');
    var toastEl = document.getElementById('toast');
    var floorOverlayEl = document.getElementById('floor-overlay');
    var floorListEl = document.getElementById('floor-list');
    var switchingOverlayEl = document.getElementById('switching-overlay');
    var switchingSpinnerEl = document.getElementById('switching-spinner');
    var switchingTitleEl = document.getElementById('switching-title');
    var switchingStepEl = document.getElementById('switching-step');
    var switchingDismissEl = document.getElementById('switching-dismiss');
    var deviceId = null;
    var refreshTimer = null;
    var currentRefreshMs = 10000;
    var selectedFloorId = null; // null = active/live floor
    var activeFloorId = null;
    var floorsData = []; // cached floors array
    var _homey = null;
    var lastManualSelection = 0;
    var toastTimer = null;
    var switchPollTimer = null;
    var isSwitching = false;
    var robotAvailable = true;
    var isMapping = false;

    // --- Toast ---
    function showToast(message, type) {
      type = type || 'info';
      toastEl.textContent = message;
      toastEl.className = type + ' show';
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(function() {
        toastEl.classList.remove('show');
      }, type === 'error' ? 5000 : 3000);
    }

    // --- Floor Bar ---
    function buildFloorBar() {
      floorBarEl.innerHTML = '';
      if (!floorsData || floorsData.length <= 1) {
        floorBarEl.style.display = 'none';
        switchFloorBtn.style.display = 'none';
        return;
      }
      floorBarEl.style.display = 'flex';

      var viewingId = selectedFloorId || activeFloorId;

      for (var i = 0; i < floorsData.length; i++) {
        (function(f) {
          var tab = document.createElement('div');
          tab.className = 'floor-tab';
          if (f.id === activeFloorId) tab.classList.add('active');
          if (f.id === viewingId) tab.classList.add('selected');
          if (!f.hasCachedMap && f.id !== activeFloorId) tab.classList.add('disabled');

          var dot = document.createElement('span');
          dot.className = 'floor-dot';
          tab.appendChild(dot);

          var label = document.createElement('span');
          label.textContent = f.name;
          tab.appendChild(label);

          if (!tab.classList.contains('disabled')) {
            tab.addEventListener('click', function() {
              selectedFloorId = f.id;
              lastManualSelection = Date.now();
              buildFloorBar();
              fetchAndRender();
              updateSwitchButton();
            });
          }

          floorBarEl.appendChild(tab);
        })(floorsData[i]);
      }

      // Gear button
      var gear = document.createElement('div');
      gear.className = 'floor-gear';
      gear.textContent = '\u2699';
      gear.addEventListener('click', function() { openFloorOverlay(); });
      floorBarEl.appendChild(gear);

      updateSwitchButton();
    }

    function updateSwitchButton() {
      var viewingId = selectedFloorId || activeFloorId;
      if (floorsData.length <= 1 || !viewingId || viewingId === activeFloorId || isSwitching || isMapping) {
        switchFloorBtn.style.display = 'none';
      } else {
        switchFloorBtn.style.display = 'block';
      }
    }

    // --- Switch Floor ---
    function showSwitchingOverlay(floorName) {
      switchingSpinnerEl.className = 'switching-spinner';
      switchingSpinnerEl.textContent = '';
      switchingTitleEl.textContent = 'Switching to ' + floorName + '…';
      switchingStepEl.textContent = 'Preparing…';
      switchingDismissEl.classList.remove('show');
      switchingOverlayEl.classList.add('show');
    }

    function showSwitchingResult(type, title, detail) {
      if (type === 'error') {
        switchingSpinnerEl.className = 'switching-spinner error';
        switchingSpinnerEl.textContent = '\u26A0'; // warning sign
      } else {
        switchingSpinnerEl.className = 'switching-spinner success';
        switchingSpinnerEl.textContent = '\u2714'; // checkmark
      }
      switchingTitleEl.textContent = title;
      switchingStepEl.textContent = detail;
      switchingDismissEl.classList.add('show');
    }

    function updateSwitchingStep(text) {
      switchingStepEl.textContent = text;
    }

    function hideSwitchingOverlay() {
      switchingOverlayEl.classList.remove('show');
    }

    switchingDismissEl.addEventListener('click', function() {
      hideSwitchingOverlay();
    });

    switchFloorBtn.addEventListener('click', function() {
      var floorId = selectedFloorId;
      if (!floorId || floorId === activeFloorId || isSwitching || isMapping) return;

      var floorName = '';
      for (var i = 0; i < floorsData.length; i++) {
        if (floorsData[i].id === floorId) { floorName = floorsData[i].name; break; }
      }

      isSwitching = true;
      switchFloorBtn.classList.add('switching');
      switchFloorBtn.textContent = 'Switching…';
      updateSwitchButton();
      showSwitchingOverlay(floorName);

      _homey.api('POST', '/switchFloor', { deviceId: deviceId, floorId: floorId })
        .then(function() {
          updateSwitchingStep('Backing up current map…');

          // Poll for active floor change
          var attempts = 0;
          var maxAttempts = 40; // 2 min at 3s intervals
          if (switchPollTimer) clearInterval(switchPollTimer);
          switchPollTimer = setInterval(function() {
            attempts++;

            // Update step text based on progress
            if (attempts <= 3) {
              updateSwitchingStep('Swapping map files…');
            } else if (attempts <= 8) {
              updateSwitchingStep('Rebooting robot…');
            } else {
              updateSwitchingStep('Waiting for robot to come back online…');
            }

            _homey.api('GET', '/floors?deviceId=' + encodeURIComponent(deviceId))
              .then(function(data) {
                if (data && data.activeFloor === floorId) {
                  clearInterval(switchPollTimer);
                  switchPollTimer = null;
                  isSwitching = false;
                  activeFloorId = floorId;
                  selectedFloorId = null;
                  showSwitchingResult('success', 'Switched to ' + floorName, 'Map loaded successfully');
                  switchFloorBtn.classList.remove('switching');
                  switchFloorBtn.textContent = 'Switch robot to this floor';
                  loadFloors();
                  fetchAndRender();
                }
              })
              .catch(function() {});

            if (attempts >= maxAttempts) {
              clearInterval(switchPollTimer);
              switchPollTimer = null;
              isSwitching = false;
              showSwitchingResult('error', 'Floor switch timed out',
                'The robot did not come back online within 2 minutes. Check that it is powered on.');
              switchFloorBtn.classList.remove('switching');
              switchFloorBtn.textContent = 'Switch robot to this floor';
              updateSwitchButton();
            }
          }, 3000);
        })
        .catch(function(err) {
          isSwitching = false;
          showSwitchingResult('error', 'Floor switch failed',
            err.message || String(err));
          switchFloorBtn.classList.remove('switching');
          switchFloorBtn.textContent = 'Switch robot to this floor';
          updateSwitchButton();
        });
    });

    // --- Floor Management Overlay ---
    function openFloorOverlay() {
      floorOverlayEl.classList.add('show');
      renderFloorList();
    }

    function closeFloorOverlay() {
      floorOverlayEl.classList.remove('show');
    }

    document.getElementById('floor-panel-close').addEventListener('click', closeFloorOverlay);
    floorOverlayEl.addEventListener('click', function(e) {
      if (e.target === floorOverlayEl) closeFloorOverlay();
    });

    function renderFloorList() {
      floorListEl.innerHTML = '';
      for (var i = 0; i < floorsData.length; i++) {
        (function(f) {
          var item = document.createElement('div');
          item.className = 'floor-item';

          // Active dot
          var dot = document.createElement('div');
          dot.className = 'floor-item-dot ' + (f.id === activeFloorId ? 'active-dot' : 'inactive-dot');
          item.appendChild(dot);

          // Editable name
          var nameInput = document.createElement('input');
          nameInput.className = 'floor-item-name';
          nameInput.type = 'text';
          nameInput.value = f.name;
          var originalName = f.name;

          nameInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
              e.preventDefault();
              nameInput.blur();
            }
            if (e.key === 'Escape') {
              nameInput.value = originalName;
              nameInput.blur();
            }
          });

          nameInput.addEventListener('blur', function() {
            var newName = nameInput.value.trim();
            if (!newName || newName === originalName) {
              nameInput.value = originalName;
              return;
            }
            _homey.api('POST', '/renameFloor', { deviceId: deviceId, floorId: f.id, newName: newName })
              .then(function() {
                originalName = newName;
                showToast('Renamed to "' + newName + '"', 'success');
                loadFloors();
              })
              .catch(function(err) {
                nameInput.value = originalName;
                showToast('Rename failed: ' + (err.message || String(err)), 'error');
              });
          });

          item.appendChild(nameInput);

          // Dock toggle button
          var dockBtn = document.createElement('button');
          dockBtn.className = 'floor-item-dock' + (f.hasDock ? ' has-dock' : '');
          dockBtn.textContent = '\u2693'; // anchor symbol
          dockBtn.title = f.hasDock ? 'Has dock (click to remove)' : 'No dock (click to add)';
          dockBtn.addEventListener('click', function() {
            var newVal = !f.hasDock;
            _homey.api('POST', '/setFloorDock', { deviceId: deviceId, floorId: f.id, hasDock: newVal })
              .then(function() {
                f.hasDock = newVal;
                dockBtn.className = 'floor-item-dock' + (newVal ? ' has-dock' : '');
                dockBtn.title = newVal ? 'Has dock (click to remove)' : 'No dock (click to add)';
                showToast((newVal ? 'Dock enabled' : 'Dock disabled') + ' for "' + f.name + '"', 'success');
              })
              .catch(function(err) {
                showToast('Failed: ' + (err.message || String(err)), 'error');
              });
          });
          item.appendChild(dockBtn);

          // Delete button
          var delBtn = document.createElement('button');
          delBtn.className = 'floor-item-delete';
          delBtn.textContent = '\u2715';
          delBtn.title = 'Delete floor';
          if (f.id === activeFloorId) delBtn.disabled = true;

          // Confirmation row
          var confirmRow = document.createElement('div');
          confirmRow.className = 'floor-item-confirm';
          var confirmLabel = document.createTextNode('Delete? ');
          var yesBtn = document.createElement('button');
          yesBtn.className = 'confirm-yes';
          yesBtn.textContent = 'Yes';
          var noBtn = document.createElement('button');
          noBtn.className = 'confirm-no';
          noBtn.textContent = 'No';
          confirmRow.appendChild(confirmLabel);
          confirmRow.appendChild(yesBtn);
          confirmRow.appendChild(noBtn);

          delBtn.addEventListener('click', function() {
            confirmRow.classList.add('show');
          });

          noBtn.addEventListener('click', function() {
            confirmRow.classList.remove('show');
          });

          yesBtn.addEventListener('click', function() {
            _homey.api('POST', '/deleteFloor', { deviceId: deviceId, floorId: f.id })
              .then(function() {
                showToast('Deleted "' + f.name + '"', 'success');
                if (selectedFloorId === f.id) selectedFloorId = null;
                loadFloors().then(function() { renderFloorList(); });
              })
              .catch(function(err) {
                showToast('Delete failed: ' + (err.message || String(err)), 'error');
                confirmRow.classList.remove('show');
              });
          });

          item.appendChild(delBtn);
          item.appendChild(confirmRow);

          floorListEl.appendChild(item);
        })(floorsData[i]);
      }
    }

    // --- Auto-Switch ---
    function checkAutoSwitch(robotState) {
      var activeStates = ['cleaning', 'returning', 'moving', 'manual_control'];
      if (!activeStates.includes(robotState)) return;
      if (!activeFloorId) return;

      // Don't fight a manual selection within the last 30 seconds
      if (Date.now() - lastManualSelection < 30000) return;

      // Auto-switch view to the active floor
      if (selectedFloorId && selectedFloorId !== activeFloorId) {
        selectedFloorId = null;
        buildFloorBar();
        fetchAndRender();
      }
    }

    // --- Connection Check ---
    function showDisconnected() {
      robotAvailable = false;
      canvas.width = 0;
      canvas.height = 0;
      floorBarEl.style.display = 'none';
      switchFloorBtn.style.display = 'none';
      statusEl.innerHTML = '<span class="status-icon">&#x1F50C;</span>'
        + 'Robot not reachable'
        + '<span class="status-hint">Waiting for connection…</span>';
      statusEl.style.display = 'block';
    }

    function showConnected() {
      if (!robotAvailable) {
        robotAvailable = true;
        statusEl.style.display = 'none';
        loadFloors();
        fetchAndRender();
      }
    }

    function scheduleRefresh() {
      refreshTimer = setTimeout(function() {
        // Check state first to determine connectivity + refresh interval
        _homey.api('GET', '/state?deviceId=' + encodeURIComponent(deviceId))
          .then(function(data) {
            currentRefreshMs = data.refreshInterval || 10000;
            if (data.available === false) {
              showDisconnected();
            } else {
              showConnected();
              var wasMapping = isMapping;
              isMapping = !!data.mapping;
              if (wasMapping !== isMapping) {
                updateSwitchButton();
                if (wasMapping && !isMapping) {
                  showToast('New floor map finalized', 'success');
                  loadFloors();
                }
              }
              fetchAndRender();
              loadFloors();
              checkAutoSwitch(data.state);
            }
          })
          .catch(function() {
            showDisconnected();
          })
          .then(function() {
            scheduleRefresh();
          });
      }, currentRefreshMs);
    }

    function onHomeyReady(Homey) {
      Homey.ready();
      _homey = Homey;

      var deviceIds = Homey.getDeviceIds();
      if (deviceIds && deviceIds.length > 0) {
        deviceId = deviceIds[0];
        // Check connectivity before loading anything
        _homey.api('GET', '/state?deviceId=' + encodeURIComponent(deviceId))
          .then(function(data) {
            currentRefreshMs = data.refreshInterval || 10000;
            if (data.available === false) {
              showDisconnected();
            } else {
              loadFloors();
              fetchAndRender();
            }
          })
          .catch(function() {
            showDisconnected();
          })
          .then(function() {
            scheduleRefresh();
          });
      } else {
        statusEl.textContent = 'Select a vacuum device in widget settings';
      }
    }

    function loadFloors() {
      return _homey.api('GET', '/floors?deviceId=' + encodeURIComponent(deviceId))
        .then(function(data) {
          if (!data || !data.floors || data.floors.length <= 1) {
            floorsData = (data && data.floors) || [];
            activeFloorId = data ? data.activeFloor : null;
            floorBarEl.style.display = 'none';
            switchFloorBtn.style.display = 'none';
            return;
          }
          activeFloorId = data.activeFloor;
          floorsData = data.floors;
          buildFloorBar();
        })
        .catch(function() {
          floorBarEl.style.display = 'none';
          switchFloorBtn.style.display = 'none';
        });
    }

    function fetchAndRender() {
      var floorId = selectedFloorId || activeFloorId;
      var url;

      if (floorId && floorId !== activeFloorId) {
        // Fetch cached map for non-active floor
        url = '/floorMap?deviceId=' + encodeURIComponent(deviceId)
          + '&floorId=' + encodeURIComponent(floorId);
      } else {
        // Fetch live map for active floor
        url = '/map?deviceId=' + encodeURIComponent(deviceId);
      }

      _homey.api('GET', url)
        .then(function(mapData) {
          if (!mapData) {
            // Map files exist on robot but no cached preview available
            statusEl.textContent = 'Switch robot to this floor to view the map';
            statusEl.style.display = 'block';
            canvas.width = 0;
            canvas.height = 0;
            return;
          }
          statusEl.style.display = 'none';
          try {
            renderMap(mapData);
          } catch (renderErr) {
            statusEl.textContent = 'Render error: ' + renderErr.message;
            statusEl.style.display = 'block';
          }
        })
        .catch(function(err) {
          statusEl.textContent = 'Error: ' + (err.message || String(err));
          statusEl.style.display = 'block';
        });
    }

    function renderMap(map) {
      var pixelSize = map.pixelSize || 5;
      var layers = map.layers || [];
      var entities = map.entities || [];

      // Decode all pixel data and compute bounding box
      var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      var decodedLayers = [];

      for (var i = 0; i < layers.length; i++) {
        var layer = layers[i];
        var pixels = decodePixels(layer);
        decodedLayers.push({ type: layer.type, pixels: pixels, metaData: layer.metaData || {} });

        for (var j = 0; j < pixels.length; j += 2) {
          var px = pixels[j];
          var py = pixels[j + 1];
          if (px < minX) minX = px;
          if (py < minY) minY = py;
          if (px > maxX) maxX = px;
          if (py > maxY) maxY = py;
        }
      }

      // Also include entities in bounding box
      for (var i = 0; i < entities.length; i++) {
        var pts = entities[i].points || [];
        for (var j = 0; j < pts.length; j += 2) {
          var ex = Math.floor(pts[j] / pixelSize);
          var ey = Math.floor(pts[j + 1] / pixelSize);
          if (ex < minX) minX = ex;
          if (ey < minY) minY = ey;
          if (ex > maxX) maxX = ex;
          if (ey > maxY) maxY = ey;
        }
      }

      if (minX > maxX) {
        statusEl.textContent = 'No map data';
        statusEl.style.display = 'block';
        return;
      }

      // Add padding
      var pad = 3;
      minX -= pad; minY -= pad; maxX += pad; maxY += pad;
      var mapW = maxX - minX + 1;
      var mapH = maxY - minY + 1;

      // Scale to fit widget
      var containerW = document.body.clientWidth;
      var containerH = document.body.clientHeight;
      var scale = Math.min(containerW / mapW, containerH / mapH);

      canvas.width = Math.ceil(mapW * scale);
      canvas.height = Math.ceil(mapH * scale);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Render layers: floor first, then segments, then walls
      var layerOrder = ['floor', 'segment', 'wall'];
      var segmentIndex = 0;

      for (var o = 0; o < layerOrder.length; o++) {
        for (var i = 0; i < decodedLayers.length; i++) {
          var dl = decodedLayers[i];
          if (dl.type !== layerOrder[o]) continue;

          var color;
          if (dl.type === 'floor') {
            color = 'rgba(86, 175, 252, 0.4)';
          } else if (dl.type === 'wall') {
            color = '#4a4a4a';
          } else if (dl.type === 'segment') {
            var ci = segmentIndex % SEGMENT_COLORS.length;
            var baseColor = SEGMENT_COLORS[ci];
            color = dl.metaData.active ? baseColor : hexToRgba(baseColor, 0.5);
            segmentIndex++;
          } else {
            color = 'rgba(100, 100, 100, 0.3)';
          }

          ctx.fillStyle = color;
          for (var j = 0; j < dl.pixels.length; j += 2) {
            var px = (dl.pixels[j] - minX) * scale;
            var py = (dl.pixels[j + 1] - minY) * scale;
            ctx.fillRect(px, py, Math.ceil(scale), Math.ceil(scale));
          }

          // Segment label
          if (dl.type === 'segment' && dl.metaData.name && dl.pixels.length > 0) {
            var cx = 0, cy = 0, cnt = dl.pixels.length / 2;
            for (var j = 0; j < dl.pixels.length; j += 2) {
              cx += dl.pixels[j];
              cy += dl.pixels[j + 1];
            }
            cx = ((cx / cnt) - minX) * scale;
            cy = ((cy / cnt) - minY) * scale;
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.font = Math.max(10, Math.round(scale * 3)) + 'px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(dl.metaData.name, cx, cy);
          }
        }
      }

      // Render entities
      for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        var pts = entity.points || [];

        if (entity.type === 'path') {
          if (pts.length < 4) continue;
          ctx.beginPath();
          ctx.moveTo(
            (Math.floor(pts[0] / pixelSize) - minX) * scale,
            (Math.floor(pts[1] / pixelSize) - minY) * scale
          );
          for (var j = 2; j < pts.length; j += 2) {
            ctx.lineTo(
              (Math.floor(pts[j] / pixelSize) - minX) * scale,
              (Math.floor(pts[j + 1] / pixelSize) - minY) * scale
            );
          }
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.lineWidth = Math.max(1, scale * 0.5);
          ctx.stroke();
        } else if (entity.type === 'predicted_path') {
          if (pts.length < 4) continue;
          ctx.beginPath();
          ctx.setLineDash([scale * 2, scale * 2]);
          ctx.moveTo(
            (Math.floor(pts[0] / pixelSize) - minX) * scale,
            (Math.floor(pts[1] / pixelSize) - minY) * scale
          );
          for (var j = 2; j < pts.length; j += 2) {
            ctx.lineTo(
              (Math.floor(pts[j] / pixelSize) - minX) * scale,
              (Math.floor(pts[j + 1] / pixelSize) - minY) * scale
            );
          }
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
          ctx.lineWidth = Math.max(1, scale * 0.5);
          ctx.stroke();
          ctx.setLineDash([]);
        } else if (entity.type === 'charger_location') {
          if (pts.length < 2) continue;
          var chX = (Math.floor(pts[0] / pixelSize) - minX) * scale;
          var chY = (Math.floor(pts[1] / pixelSize) - minY) * scale;
          var chR = Math.max(4, scale * 2);
          ctx.beginPath();
          ctx.arc(chX, chY, chR, 0, Math.PI * 2);
          ctx.fillStyle = '#4caf50';
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1.5;
          ctx.stroke();
        } else if (entity.type === 'robot_position') {
          if (pts.length < 2) continue;
          var rX = (Math.floor(pts[0] / pixelSize) - minX) * scale;
          var rY = (Math.floor(pts[1] / pixelSize) - minY) * scale;
          var rR = Math.max(5, scale * 2.5);
          ctx.beginPath();
          ctx.arc(rX, rY, rR, 0, Math.PI * 2);
          ctx.fillStyle = '#f44336';
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1.5;
          ctx.stroke();

          // Direction indicator
          if (entity.metaData && typeof entity.metaData.angle === 'number') {
            var angle = (entity.metaData.angle * Math.PI) / 180;
            ctx.beginPath();
            ctx.moveTo(rX, rY);
            ctx.lineTo(rX + Math.cos(angle) * rR * 2, rY + Math.sin(angle) * rR * 2);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        } else if (entity.type === 'virtual_wall') {
          if (pts.length < 4) continue;
          ctx.beginPath();
          ctx.setLineDash([scale * 2, scale]);
          ctx.moveTo(
            (Math.floor(pts[0] / pixelSize) - minX) * scale,
            (Math.floor(pts[1] / pixelSize) - minY) * scale
          );
          for (var j = 2; j < pts.length; j += 2) {
            ctx.lineTo(
              (Math.floor(pts[j] / pixelSize) - minX) * scale,
              (Math.floor(pts[j + 1] / pixelSize) - minY) * scale
            );
          }
          ctx.strokeStyle = '#f44336';
          ctx.lineWidth = Math.max(2, scale);
          ctx.stroke();
          ctx.setLineDash([]);
        } else if (entity.type === 'no_go_area' || entity.type === 'no_mop_area') {
          if (pts.length < 8) continue;
          ctx.beginPath();
          ctx.moveTo(
            (Math.floor(pts[0] / pixelSize) - minX) * scale,
            (Math.floor(pts[1] / pixelSize) - minY) * scale
          );
          for (var j = 2; j < pts.length; j += 2) {
            ctx.lineTo(
              (Math.floor(pts[j] / pixelSize) - minX) * scale,
              (Math.floor(pts[j + 1] / pixelSize) - minY) * scale
            );
          }
          ctx.closePath();
          ctx.fillStyle = entity.type === 'no_go_area'
            ? 'rgba(244, 67, 54, 0.25)'
            : 'rgba(33, 150, 243, 0.25)';
          ctx.fill();
          ctx.strokeStyle = entity.type === 'no_go_area' ? '#f44336' : '#2196f3';
          ctx.lineWidth = 1;
          ctx.stroke();
        } else if (entity.type === 'active_zone') {
          if (pts.length < 8) continue;
          ctx.beginPath();
          ctx.moveTo(
            (Math.floor(pts[0] / pixelSize) - minX) * scale,
            (Math.floor(pts[1] / pixelSize) - minY) * scale
          );
          for (var j = 2; j < pts.length; j += 2) {
            ctx.lineTo(
              (Math.floor(pts[j] / pixelSize) - minX) * scale,
              (Math.floor(pts[j + 1] / pixelSize) - minY) * scale
            );
          }
          ctx.closePath();
          ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
          ctx.fill();
          ctx.strokeStyle = '#4caf50';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
    }

    function decodePixels(layer) {
      // If flat pixel pairs are provided directly
      if (layer.pixels && layer.pixels.length > 0) {
        return layer.pixels;
      }
      // Decompress RLE: triplets [xStart, y, count]
      var compressed = layer.compressedPixels;
      if (!compressed || compressed.length === 0) return [];

      var result = [];
      for (var i = 0; i < compressed.length; i += 3) {
        var xStart = compressed[i];
        var y = compressed[i + 1];
        var count = compressed[i + 2];
        for (var x = xStart; x < xStart + count; x++) {
          result.push(x, y);
        }
      }
      return result;
    }

    function hexToRgba(hex, alpha) {
      var r = parseInt(hex.slice(1, 3), 16);
      var g = parseInt(hex.slice(3, 5), 16);
      var b = parseInt(hex.slice(5, 7), 16);
      return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
    }
  </script>
</body>
</html>
