<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: var(--homey-background-color, #111);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
    #status {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--homey-text-color, #aaa);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 14px;
    }
    #floor-picker {
      position: absolute;
      top: 8px;
      right: 8px;
      display: none;
    }
    #floor-picker select {
      background: rgba(0, 0, 0, 0.6);
      color: var(--homey-text-color, #fff);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      padding: 4px 8px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 12px;
      cursor: pointer;
      outline: none;
    }
    #floor-picker select:hover {
      border-color: rgba(255, 255, 255, 0.4);
    }
    #floor-picker select option {
      background: #222;
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="status">Loading map…</div>
  <canvas id="map"></canvas>
  <div id="floor-picker"><select id="floor-select"></select></div>

  <script>
    // Segment color palette
    var SEGMENT_COLORS = [
      '#56affc', '#fc5656', '#56fc7e', '#fcb056',
      '#b056fc', '#56fce8', '#fc56b0', '#a2fc56',
      '#5668fc', '#fce856', '#fc5680', '#56fcb0'
    ];

    var canvas = document.getElementById('map');
    var ctx = canvas.getContext('2d');
    var statusEl = document.getElementById('status');
    var floorPickerEl = document.getElementById('floor-picker');
    var floorSelectEl = document.getElementById('floor-select');
    var deviceId = null;
    var refreshTimer = null;
    var selectedFloorId = null; // null = active/live floor
    var activeFloorId = null;
    var _homey = null;

    function onHomeyReady(Homey) {
      Homey.ready();
      _homey = Homey;

      var deviceIds = Homey.getDeviceIds();
      if (deviceIds && deviceIds.length > 0) {
        deviceId = deviceIds[0];
        loadFloors();
        fetchAndRender();
        refreshTimer = setInterval(function() {
          fetchAndRender();
          loadFloors(); // refresh floor list periodically
        }, 10000);
      } else {
        statusEl.textContent = 'Select a vacuum device in widget settings';
      }
    }

    function loadFloors() {
      _homey.api('GET', '/floors?deviceId=' + encodeURIComponent(deviceId))
        .then(function(data) {
          if (!data || !data.floors || data.floors.length <= 1) {
            floorPickerEl.style.display = 'none';
            return;
          }
          activeFloorId = data.activeFloor;
          floorPickerEl.style.display = 'block';

          // Remember current selection
          var currentVal = floorSelectEl.value;

          // Rebuild options
          floorSelectEl.innerHTML = '';
          for (var i = 0; i < data.floors.length; i++) {
            var f = data.floors[i];
            var opt = document.createElement('option');
            opt.value = f.id;
            opt.textContent = f.name + (f.id === data.activeFloor ? ' ●' : '');
            if (!f.hasCachedMap && f.id !== data.activeFloor) {
              opt.disabled = true;
              opt.textContent = f.name + ' (no map)';
            }
            floorSelectEl.appendChild(opt);
          }

          // Restore selection
          if (selectedFloorId) {
            floorSelectEl.value = selectedFloorId;
          } else {
            floorSelectEl.value = data.activeFloor;
          }
        })
        .catch(function() {
          floorPickerEl.style.display = 'none';
        });
    }

    floorSelectEl.addEventListener('change', function() {
      var val = floorSelectEl.value;
      selectedFloorId = val;
      fetchAndRender();
    });

    function fetchAndRender() {
      var floorId = selectedFloorId || activeFloorId;
      var url;

      if (floorId && floorId !== activeFloorId) {
        // Fetch cached map for non-active floor
        url = '/floorMap?deviceId=' + encodeURIComponent(deviceId)
          + '&floorId=' + encodeURIComponent(floorId);
      } else {
        // Fetch live map for active floor
        url = '/map?deviceId=' + encodeURIComponent(deviceId);
      }

      _homey.api('GET', url)
        .then(function(mapData) {
          if (!mapData) {
            statusEl.textContent = 'No map data returned';
            statusEl.style.display = 'block';
            return;
          }
          statusEl.style.display = 'none';
          try {
            renderMap(mapData);
          } catch (renderErr) {
            statusEl.textContent = 'Render error: ' + renderErr.message;
            statusEl.style.display = 'block';
          }
        })
        .catch(function(err) {
          statusEl.textContent = 'Error: ' + (err.message || String(err));
          statusEl.style.display = 'block';
        });
    }

    function renderMap(map) {
      var pixelSize = map.pixelSize || 5;
      var layers = map.layers || [];
      var entities = map.entities || [];

      // Decode all pixel data and compute bounding box
      var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      var decodedLayers = [];

      for (var i = 0; i < layers.length; i++) {
        var layer = layers[i];
        var pixels = decodePixels(layer);
        decodedLayers.push({ type: layer.type, pixels: pixels, metaData: layer.metaData || {} });

        for (var j = 0; j < pixels.length; j += 2) {
          var px = pixels[j];
          var py = pixels[j + 1];
          if (px < minX) minX = px;
          if (py < minY) minY = py;
          if (px > maxX) maxX = px;
          if (py > maxY) maxY = py;
        }
      }

      // Also include entities in bounding box
      for (var i = 0; i < entities.length; i++) {
        var pts = entities[i].points || [];
        for (var j = 0; j < pts.length; j += 2) {
          var ex = Math.floor(pts[j] / pixelSize);
          var ey = Math.floor(pts[j + 1] / pixelSize);
          if (ex < minX) minX = ex;
          if (ey < minY) minY = ey;
          if (ex > maxX) maxX = ex;
          if (ey > maxY) maxY = ey;
        }
      }

      if (minX > maxX) {
        statusEl.textContent = 'No map data';
        statusEl.style.display = 'block';
        return;
      }

      // Add padding
      var pad = 3;
      minX -= pad; minY -= pad; maxX += pad; maxY += pad;
      var mapW = maxX - minX + 1;
      var mapH = maxY - minY + 1;

      // Scale to fit widget
      var containerW = document.body.clientWidth;
      var containerH = document.body.clientHeight;
      var scale = Math.min(containerW / mapW, containerH / mapH);

      canvas.width = Math.ceil(mapW * scale);
      canvas.height = Math.ceil(mapH * scale);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Render layers: floor first, then segments, then walls
      var layerOrder = ['floor', 'segment', 'wall'];
      var segmentIndex = 0;

      for (var o = 0; o < layerOrder.length; o++) {
        for (var i = 0; i < decodedLayers.length; i++) {
          var dl = decodedLayers[i];
          if (dl.type !== layerOrder[o]) continue;

          var color;
          if (dl.type === 'floor') {
            color = 'rgba(86, 175, 252, 0.4)';
          } else if (dl.type === 'wall') {
            color = '#4a4a4a';
          } else if (dl.type === 'segment') {
            var ci = segmentIndex % SEGMENT_COLORS.length;
            var baseColor = SEGMENT_COLORS[ci];
            color = dl.metaData.active ? baseColor : hexToRgba(baseColor, 0.5);
            segmentIndex++;
          } else {
            color = 'rgba(100, 100, 100, 0.3)';
          }

          ctx.fillStyle = color;
          for (var j = 0; j < dl.pixels.length; j += 2) {
            var px = (dl.pixels[j] - minX) * scale;
            var py = (dl.pixels[j + 1] - minY) * scale;
            ctx.fillRect(px, py, Math.ceil(scale), Math.ceil(scale));
          }

          // Segment label
          if (dl.type === 'segment' && dl.metaData.name && dl.pixels.length > 0) {
            var cx = 0, cy = 0, cnt = dl.pixels.length / 2;
            for (var j = 0; j < dl.pixels.length; j += 2) {
              cx += dl.pixels[j];
              cy += dl.pixels[j + 1];
            }
            cx = ((cx / cnt) - minX) * scale;
            cy = ((cy / cnt) - minY) * scale;
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.font = Math.max(10, Math.round(scale * 3)) + 'px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(dl.metaData.name, cx, cy);
          }
        }
      }

      // Render entities
      for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        var pts = entity.points || [];

        if (entity.type === 'path') {
          if (pts.length < 4) continue;
          ctx.beginPath();
          ctx.moveTo(
            (Math.floor(pts[0] / pixelSize) - minX) * scale,
            (Math.floor(pts[1] / pixelSize) - minY) * scale
          );
          for (var j = 2; j < pts.length; j += 2) {
            ctx.lineTo(
              (Math.floor(pts[j] / pixelSize) - minX) * scale,
              (Math.floor(pts[j + 1] / pixelSize) - minY) * scale
            );
          }
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.lineWidth = Math.max(1, scale * 0.5);
          ctx.stroke();
        } else if (entity.type === 'predicted_path') {
          if (pts.length < 4) continue;
          ctx.beginPath();
          ctx.setLineDash([scale * 2, scale * 2]);
          ctx.moveTo(
            (Math.floor(pts[0] / pixelSize) - minX) * scale,
            (Math.floor(pts[1] / pixelSize) - minY) * scale
          );
          for (var j = 2; j < pts.length; j += 2) {
            ctx.lineTo(
              (Math.floor(pts[j] / pixelSize) - minX) * scale,
              (Math.floor(pts[j + 1] / pixelSize) - minY) * scale
            );
          }
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
          ctx.lineWidth = Math.max(1, scale * 0.5);
          ctx.stroke();
          ctx.setLineDash([]);
        } else if (entity.type === 'charger_location') {
          if (pts.length < 2) continue;
          var chX = (Math.floor(pts[0] / pixelSize) - minX) * scale;
          var chY = (Math.floor(pts[1] / pixelSize) - minY) * scale;
          var chR = Math.max(4, scale * 2);
          ctx.beginPath();
          ctx.arc(chX, chY, chR, 0, Math.PI * 2);
          ctx.fillStyle = '#4caf50';
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1.5;
          ctx.stroke();
        } else if (entity.type === 'robot_position') {
          if (pts.length < 2) continue;
          var rX = (Math.floor(pts[0] / pixelSize) - minX) * scale;
          var rY = (Math.floor(pts[1] / pixelSize) - minY) * scale;
          var rR = Math.max(5, scale * 2.5);
          ctx.beginPath();
          ctx.arc(rX, rY, rR, 0, Math.PI * 2);
          ctx.fillStyle = '#f44336';
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1.5;
          ctx.stroke();

          // Direction indicator
          if (entity.metaData && typeof entity.metaData.angle === 'number') {
            var angle = (entity.metaData.angle * Math.PI) / 180;
            ctx.beginPath();
            ctx.moveTo(rX, rY);
            ctx.lineTo(rX + Math.cos(angle) * rR * 2, rY + Math.sin(angle) * rR * 2);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        } else if (entity.type === 'virtual_wall') {
          if (pts.length < 4) continue;
          ctx.beginPath();
          ctx.setLineDash([scale * 2, scale]);
          ctx.moveTo(
            (Math.floor(pts[0] / pixelSize) - minX) * scale,
            (Math.floor(pts[1] / pixelSize) - minY) * scale
          );
          for (var j = 2; j < pts.length; j += 2) {
            ctx.lineTo(
              (Math.floor(pts[j] / pixelSize) - minX) * scale,
              (Math.floor(pts[j + 1] / pixelSize) - minY) * scale
            );
          }
          ctx.strokeStyle = '#f44336';
          ctx.lineWidth = Math.max(2, scale);
          ctx.stroke();
          ctx.setLineDash([]);
        } else if (entity.type === 'no_go_area' || entity.type === 'no_mop_area') {
          if (pts.length < 8) continue;
          ctx.beginPath();
          ctx.moveTo(
            (Math.floor(pts[0] / pixelSize) - minX) * scale,
            (Math.floor(pts[1] / pixelSize) - minY) * scale
          );
          for (var j = 2; j < pts.length; j += 2) {
            ctx.lineTo(
              (Math.floor(pts[j] / pixelSize) - minX) * scale,
              (Math.floor(pts[j + 1] / pixelSize) - minY) * scale
            );
          }
          ctx.closePath();
          ctx.fillStyle = entity.type === 'no_go_area'
            ? 'rgba(244, 67, 54, 0.25)'
            : 'rgba(33, 150, 243, 0.25)';
          ctx.fill();
          ctx.strokeStyle = entity.type === 'no_go_area' ? '#f44336' : '#2196f3';
          ctx.lineWidth = 1;
          ctx.stroke();
        } else if (entity.type === 'active_zone') {
          if (pts.length < 8) continue;
          ctx.beginPath();
          ctx.moveTo(
            (Math.floor(pts[0] / pixelSize) - minX) * scale,
            (Math.floor(pts[1] / pixelSize) - minY) * scale
          );
          for (var j = 2; j < pts.length; j += 2) {
            ctx.lineTo(
              (Math.floor(pts[j] / pixelSize) - minX) * scale,
              (Math.floor(pts[j + 1] / pixelSize) - minY) * scale
            );
          }
          ctx.closePath();
          ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
          ctx.fill();
          ctx.strokeStyle = '#4caf50';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
    }

    function decodePixels(layer) {
      // If flat pixel pairs are provided directly
      if (layer.pixels && layer.pixels.length > 0) {
        return layer.pixels;
      }
      // Decompress RLE: triplets [xStart, y, count]
      var compressed = layer.compressedPixels;
      if (!compressed || compressed.length === 0) return [];

      var result = [];
      for (var i = 0; i < compressed.length; i += 3) {
        var xStart = compressed[i];
        var y = compressed[i + 1];
        var count = compressed[i + 2];
        for (var x = xStart; x < xStart + count; x++) {
          result.push(x, y);
        }
      }
      return result;
    }

    function hexToRgba(hex, alpha) {
      var r = parseInt(hex.slice(1, 3), 16);
      var g = parseInt(hex.slice(3, 5), 16);
      var b = parseInt(hex.slice(5, 7), 16);
      return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
    }
  </script>
</body>
</html>
